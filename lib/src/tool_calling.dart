import 'dart:convert';

/// Tool definition for LLM tool calling.
class Tool {
  /// Unique name for the tool.
  final String name;

  /// Description of what the tool does.
  final String description;

  /// JSON Schema defining the tool's parameters.
  final Map<String, dynamic> parameters;

  const Tool({
    required this.name,
    required this.description,
    required this.parameters,
  });

  /// Convert to JSON representation.
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'parameters': parameters,
      };

  @override
  String toString() => 'Tool($name)';
}

/// Result of a tool call generated by the model.
class ToolCall {
  /// Unique identifier for this call.
  final String id;

  /// Name of the tool to call.
  final String name;

  /// Arguments to pass to the tool.
  final Map<String, dynamic> arguments;

  const ToolCall({
    required this.id,
    required this.name,
    required this.arguments,
  });

  /// Create from JSON map.
  factory ToolCall.fromJson(Map<String, dynamic> json) {
    return ToolCall(
      id: json['id'] as String? ?? 'call_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String,
      arguments: json['arguments'] is String
          ? jsonDecode(json['arguments'] as String) as Map<String, dynamic>
          : json['arguments'] as Map<String, dynamic>,
    );
  }

  /// Convert to JSON representation.
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'arguments': arguments,
      };

  @override
  String toString() => 'ToolCall($name, $arguments)';
}

/// Controls how the model chooses tools.
enum ToolChoiceType {
  /// Model decides whether to call tools.
  auto,

  /// Never call tools, just respond.
  none,

  /// Must call at least one tool.
  required,

  /// Call a specific tool by name.
  specific,
}

/// Configuration for tool selection behavior.
class ToolChoice {
  final ToolChoiceType type;
  final String? toolName;

  const ToolChoice._({required this.type, this.toolName});

  /// Let the model decide whether to call tools.
  const ToolChoice.auto()
      : type = ToolChoiceType.auto,
        toolName = null;

  /// Never call tools.
  const ToolChoice.none()
      : type = ToolChoiceType.none,
        toolName = null;

  /// Must call at least one tool.
  const ToolChoice.required()
      : type = ToolChoiceType.required,
        toolName = null;

  /// Call a specific tool by name.
  ToolChoice.specific(String name)
      : type = ToolChoiceType.specific,
        toolName = name;
}

/// Parameters for tool call generation.
class ToolCallParams {
  /// The user prompt.
  final String prompt;

  /// Available tools.
  final List<Tool> tools;

  /// Tool selection behavior.
  final ToolChoice toolChoice;

  /// Maximum tokens to generate.
  final int maxTokens;

  /// Sampling temperature (0.0 - 2.0).
  final double temperature;

  /// Random seed for reproducibility.
  final int? seed;

  /// Allow multiple tool calls in one response.
  final bool allowMultipleCalls;

  /// Maximum number of tool calls.
  final int maxCalls;

  const ToolCallParams({
    required this.prompt,
    required this.tools,
    this.toolChoice = const ToolChoice.auto(),
    this.maxTokens = 256,
    this.temperature = 0.1,
    this.seed,
    this.allowMultipleCalls = false,
    this.maxCalls = 1,
  });
}

/// Parameters for JSON generation.
class JsonParams {
  /// The user prompt.
  final String prompt;

  /// JSON Schema for the expected output.
  final Map<String, dynamic> schema;

  /// Maximum tokens to generate.
  final int maxTokens;

  /// Sampling temperature (0.0 - 2.0).
  final double temperature;

  /// Random seed for reproducibility.
  final int? seed;

  const JsonParams({
    required this.prompt,
    required this.schema,
    this.maxTokens = 256,
    this.temperature = 0.1,
    this.seed,
  });
}

/// Message role for chat conversations.
enum MessageRole {
  system,
  user,
  assistant,
  tool,
}

/// A message in a chat conversation.
class Message {
  final MessageRole role;
  final String content;
  final ToolCall? toolCall;
  final String? toolCallId;

  const Message._({
    required this.role,
    required this.content,
    this.toolCall,
    this.toolCallId,
  });

  /// Create a system message.
  factory Message.system(String content) => Message._(
        role: MessageRole.system,
        content: content,
      );

  /// Create a user message.
  factory Message.user(String content) => Message._(
        role: MessageRole.user,
        content: content,
      );

  /// Create an assistant message.
  factory Message.assistant(String content) => Message._(
        role: MessageRole.assistant,
        content: content,
      );

  /// Create a tool call message.
  factory Message.toolCall(ToolCall call) => Message._(
        role: MessageRole.assistant,
        content: '',
        toolCall: call,
      );

  /// Create a tool result message.
  factory Message.toolResult({
    required String toolCallId,
    required String name,
    required String result,
  }) =>
      Message._(
        role: MessageRole.tool,
        content: result,
        toolCallId: toolCallId,
      );

  /// Convert to JSON representation.
  Map<String, dynamic> toJson() {
    final json = <String, dynamic>{
      'role': role.name,
      'content': content,
    };
    if (toolCall != null) {
      json['tool_call'] = toolCall!.toJson();
    }
    if (toolCallId != null) {
      json['tool_call_id'] = toolCallId;
    }
    return json;
  }
}

/// Helper to build tool definitions with common patterns.
class ToolBuilder {
  final String _name;
  final String _description;
  final Map<String, dynamic> _properties = {};
  final List<String> _required = [];

  ToolBuilder(this._name, this._description);

  /// Add a string parameter.
  ToolBuilder addString(String name, String description, {bool required = false}) {
    _properties[name] = {
      'type': 'string',
      'description': description,
    };
    if (required) _required.add(name);
    return this;
  }

  /// Add an integer parameter.
  ToolBuilder addInteger(String name, String description, {bool required = false}) {
    _properties[name] = {
      'type': 'integer',
      'description': description,
    };
    if (required) _required.add(name);
    return this;
  }

  /// Add a number parameter.
  ToolBuilder addNumber(String name, String description, {bool required = false}) {
    _properties[name] = {
      'type': 'number',
      'description': description,
    };
    if (required) _required.add(name);
    return this;
  }

  /// Add a boolean parameter.
  ToolBuilder addBoolean(String name, String description, {bool required = false}) {
    _properties[name] = {
      'type': 'boolean',
      'description': description,
    };
    if (required) _required.add(name);
    return this;
  }

  /// Add an enum parameter.
  ToolBuilder addEnum(String name, String description, List<String> values,
      {bool required = false}) {
    _properties[name] = {
      'type': 'string',
      'description': description,
      'enum': values,
    };
    if (required) _required.add(name);
    return this;
  }

  /// Build the tool.
  Tool build() {
    return Tool(
      name: _name,
      description: _description,
      parameters: {
        'type': 'object',
        'properties': _properties,
        'required': _required,
      },
    );
  }
}

/// Helper to build JSON schemas.
class JsonSchemaBuilder {
  final Map<String, dynamic> _schema = {'type': 'object'};
  final Map<String, dynamic> _properties = {};
  final List<String> _required = [];

  /// Add a string property.
  JsonSchemaBuilder addString(String name, {bool required = false}) {
    _properties[name] = {'type': 'string'};
    if (required) _required.add(name);
    return this;
  }

  /// Add an integer property.
  JsonSchemaBuilder addInteger(String name, {bool required = false}) {
    _properties[name] = {'type': 'integer'};
    if (required) _required.add(name);
    return this;
  }

  /// Add a number property.
  JsonSchemaBuilder addNumber(String name, {bool required = false}) {
    _properties[name] = {'type': 'number'};
    if (required) _required.add(name);
    return this;
  }

  /// Add a boolean property.
  JsonSchemaBuilder addBoolean(String name, {bool required = false}) {
    _properties[name] = {'type': 'boolean'};
    if (required) _required.add(name);
    return this;
  }

  /// Add an array property.
  JsonSchemaBuilder addArray(String name, Map<String, dynamic> items,
      {bool required = false}) {
    _properties[name] = {
      'type': 'array',
      'items': items,
    };
    if (required) _required.add(name);
    return this;
  }

  /// Build the schema.
  Map<String, dynamic> build() {
    return {
      'type': 'object',
      'properties': _properties,
      'required': _required,
    };
  }
}
